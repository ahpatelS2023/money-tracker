{"ast":null,"code":"import _toConsumableArray from \"/Users/amipatel/Desktop/money-tracker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"/Users/amipatel/Desktop/money-tracker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\n\n/**\n * Immutable map helper. All operations return new map copied from previous map.\n */\nvar EntityMap = {\n  /**\n   * Create new entity map from given array.\n   *\n   * @param {array} entities\n   * @param {string} keyPropName\n   * @return {object}\n   */\n  fromArray: function fromArray(entities) {\n    var keyPropName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'id';\n    return EntityMap.merge({\n      byKey: {},\n      keys: []\n    }, entities, keyPropName);\n  },\n\n  /**\n   * Merge given entities into given map.\n   *\n   * @param {object} source\n   * @param {array} entities\n   * @return {object}\n   */\n  merge: function merge(source, entities) {\n    var keyPropName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'id';\n    return {\n      byKey: _objectSpread({}, source.byKey, entities.reduce(function (acc, entity) {\n        acc[entity[keyPropName]] = entity;\n        return acc;\n      }, {})),\n      keys: _toConsumableArray(new Set(entities.map(function (entity) {\n        return entity[keyPropName];\n      }).filter(function (key) {\n        return !source.keys.includes(key);\n      }).concat(source.keys)))\n    };\n  },\n\n  /**\n   * Set given entity in map.\n   *\n   * @param {object} source\n   * @param {striobjectng} entity\n   */\n  set: function set(source, entity) {\n    var keyPropName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'id';\n    return EntityMap.merge(source, [entity], keyPropName);\n  },\n\n  /**\n   * Remove value by given key.\n   *\n   * @param {object} source\n   * @param {string} key\n   * @return {object}\n   */\n  remove: function remove(source, key) {\n    if (!source.byKey || !source.byKey[key]) return source;\n    var keys = source.keys.filter(function (originalKey) {\n      return originalKey !== key;\n    });\n    return {\n      byKey: keys.reduce(function (acc, key) {\n        acc[key] = source.byKey[key];\n        return acc;\n      }, {}),\n      keys: keys\n    };\n  },\n\n  /**\n   * Retrieve value by given key.\n   *\n   * @param {object} source\n   * @param {string} key\n   */\n  get: function get(source, key) {\n    var fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return source.byKey && source.byKey[key] || fallback;\n  },\n\n  /**\n   * Map over all entities with given function and return array with results.\n   * Optionally slice mapping to given offset and limit.\n   *\n   * @param {object} source\n   * @param {function} fn\n   * @param {number} limit\n   * @param {number} offset\n   * @return {array}\n   */\n  map: function map(source, fn) {\n    var limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : source.keys.length;\n    var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    return source.keys.slice(offset, offset + limit).map(function (key) {\n      return fn(source.byKey[key], key);\n    });\n  },\n\n  /**\n   * Filter source entires with given function and return array of entries matching the filter.\n   *\n   * @param {object} source\n   * @param {function} fn\n   * @return {array}\n   */\n  filter: function filter(source, fn) {\n    return source.keys.reduce(function (acc, key) {\n      if (fn(source.byKey[key], key)) {\n        acc.push(source.byKey[key]);\n      }\n\n      return acc;\n    }, []);\n  },\n\n  /**\n   * Apply given function to all entities and return new map with results.\n   *\n   * @param {object} source\n   * @param {function} fn\n   * @return {object}\n   */\n  apply: function apply(source, fn) {\n    return {\n      byKey: source.keys.reduce(function (acc, key) {\n        acc[key] = fn(source.byKey[key], key);\n        return acc;\n      }, {}),\n      keys: source.keys\n    };\n  }\n};\nexport default EntityMap;","map":{"version":3,"sources":["/Users/amipatel/Desktop/money-tracker/src/entities/EntityMap.js"],"names":["EntityMap","fromArray","entities","keyPropName","merge","byKey","keys","source","reduce","acc","entity","Set","map","filter","key","includes","concat","set","remove","originalKey","get","fallback","fn","limit","length","offset","slice","push","apply"],"mappings":"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","sourcesContent":["/**\n * Immutable map helper. All operations return new map copied from previous map.\n */\nconst EntityMap = {\n  /**\n   * Create new entity map from given array.\n   *\n   * @param {array} entities\n   * @param {string} keyPropName\n   * @return {object}\n   */\n  fromArray(entities, keyPropName = 'id') {\n    return EntityMap.merge({ byKey: {}, keys: [] }, entities, keyPropName);\n  },\n  /**\n   * Merge given entities into given map.\n   *\n   * @param {object} source\n   * @param {array} entities\n   * @return {object}\n   */\n  merge(source, entities, keyPropName = 'id') {\n    return {\n      byKey: {\n        ...source.byKey,\n        ...entities.reduce((acc, entity) => {\n          acc[entity[keyPropName]] = entity;\n          return acc;\n        }, {})\n      },\n      keys: [\n        ...new Set(\n          entities\n            .map(entity => entity[keyPropName])\n            .filter(key => !source.keys.includes(key))\n            .concat(source.keys)\n        )\n      ]\n    };\n  },\n  /**\n   * Set given entity in map.\n   *\n   * @param {object} source\n   * @param {striobjectng} entity\n   */\n  set(source, entity, keyPropName = 'id') {\n    return EntityMap.merge(source, [entity], keyPropName);\n  },\n  /**\n   * Remove value by given key.\n   *\n   * @param {object} source\n   * @param {string} key\n   * @return {object}\n   */\n  remove(source, key) {\n    if (!source.byKey || !source.byKey[key]) return source;\n\n    const keys = source.keys.filter(originalKey => originalKey !== key);\n    return {\n      byKey: keys.reduce((acc, key) => {\n        acc[key] = source.byKey[key];\n        return acc;\n      }, {}),\n      keys\n    };\n  },\n  /**\n   * Retrieve value by given key.\n   *\n   * @param {object} source\n   * @param {string} key\n   */\n  get(source, key, fallback = {}) {\n    return (source.byKey && source.byKey[key]) || fallback;\n  },\n  /**\n   * Map over all entities with given function and return array with results.\n   * Optionally slice mapping to given offset and limit.\n   *\n   * @param {object} source\n   * @param {function} fn\n   * @param {number} limit\n   * @param {number} offset\n   * @return {array}\n   */\n  map(source, fn, limit = source.keys.length, offset = 0) {\n    return source.keys\n      .slice(offset, offset + limit)\n      .map(key => fn(source.byKey[key], key));\n  },\n  /**\n   * Filter source entires with given function and return array of entries matching the filter.\n   *\n   * @param {object} source\n   * @param {function} fn\n   * @return {array}\n   */\n  filter(source, fn) {\n    return source.keys.reduce((acc, key) => {\n      if (fn(source.byKey[key], key)) {\n        acc.push(source.byKey[key]);\n      }\n      return acc;\n    }, []);\n  },\n  /**\n   * Apply given function to all entities and return new map with results.\n   *\n   * @param {object} source\n   * @param {function} fn\n   * @return {object}\n   */\n  apply(source, fn) {\n    return {\n      byKey: source.keys.reduce((acc, key) => {\n        acc[key] = fn(source.byKey[key], key);\n        return acc;\n      }, {}),\n      keys: source.keys\n    };\n  }\n};\n\nexport default EntityMap;\n"]},"metadata":{},"sourceType":"module"}