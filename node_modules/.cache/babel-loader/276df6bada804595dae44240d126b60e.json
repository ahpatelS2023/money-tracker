{"ast":null,"code":"!function (t, e) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = e() : \"function\" == typeof define && define.amd ? define([], e) : \"object\" == typeof exports ? exports.ReactTracker = e() : t.ReactTracker = e();\n}(\"undefined\" != typeof self ? self : this, function () {\n  return function (t) {\n    function e(r) {\n      if (n[r]) return n[r].exports;\n      var o = n[r] = {\n        i: r,\n        l: !1,\n        exports: {}\n      };\n      return t[r].call(o.exports, o, o.exports, e), o.l = !0, o.exports;\n    }\n\n    var n = {};\n    return e.m = t, e.c = n, e.d = function (t, n, r) {\n      e.o(t, n) || Object.defineProperty(t, n, {\n        configurable: !1,\n        enumerable: !0,\n        get: r\n      });\n    }, e.n = function (t) {\n      var n = t && t.__esModule ? function () {\n        return t.default;\n      } : function () {\n        return t;\n      };\n      return e.d(n, \"a\", n), n;\n    }, e.o = function (t, e) {\n      return Object.prototype.hasOwnProperty.call(t, e);\n    }, e.p = \"build/\", e(e.s = 4);\n  }([function (t, e, n) {\n    \"use strict\";\n\n    t.exports = n(6);\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return function () {\n        return t;\n      };\n    }\n\n    var o = function o() {};\n\n    o.thatReturns = r, o.thatReturnsFalse = r(!1), o.thatReturnsTrue = r(!0), o.thatReturnsNull = r(null), o.thatReturnsThis = function () {\n      return this;\n    }, o.thatReturnsArgument = function (t) {\n      return t;\n    }, t.exports = o;\n  }, function (t, e, n) {\n    t.exports = n(9)();\n  }, function (t, e, n) {\n    \"use strict\";\n\n    n.d(e, \"b\", function () {\n      return r;\n    }), n.d(e, \"a\", function () {\n      return o;\n    });\n\n    var r = function r(t) {\n      return \"TrackEventProvider(\" + (t.displayName || t.name || \"Component\") + \")\";\n    },\n        o = function o() {\n      return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []).filter(function (t) {\n        return \"function\" == typeof t;\n      });\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n    var r = n(5),\n        o = n(12),\n        i = n(13);\n    n.d(e, \"Tracker\", function () {\n      return i.a;\n    }), n.d(e, \"TrackerProvider\", function () {\n      return r.a;\n    }), n.d(e, \"withTracking\", function () {\n      return o.a;\n    });\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function o(t, e) {\n      if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n    }\n\n    function i(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n    }\n\n    var u = n(0),\n        c = (n.n(u), n(2)),\n        a = n.n(c),\n        f = function () {\n      function t(t, e) {\n        for (var n = 0; e.length > n; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }(),\n        l = function (t) {\n      function e(t, n) {\n        r(this, e);\n        var i = o(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));\n        return i.tracker = t.tracker, i;\n      }\n\n      return i(e, t), f(e, [{\n        key: \"getChildContext\",\n        value: function value() {\n          return {\n            trackEvent: this.tracker.trackEvent\n          };\n        }\n      }]), f(e, [{\n        key: \"render\",\n        value: function value() {\n          return u.Children.only(this.props.children);\n        }\n      }]), e;\n    }(u.Component);\n\n    e.a = l, l.propTypes = {\n      children: a.a.element.isRequired\n    }, l.childContextTypes = {\n      trackEvent: a.a.func.isRequired\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      for (var e = arguments.length - 1, n = \"Minified React error #\" + t + \"; visit http://facebook.github.io/react/docs/error-decoder.html?invariant=\" + t, r = 0; e > r; r++) {\n        n += \"&args[]=\" + encodeURIComponent(arguments[r + 1]);\n      }\n\n      throw e = Error(n + \" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.\"), e.name = \"Invariant Violation\", e.framesToPop = 1, e;\n    }\n\n    function o(t, e, n) {\n      this.props = t, this.context = e, this.refs = g, this.updater = n || P;\n    }\n\n    function i(t, e, n) {\n      this.props = t, this.context = e, this.refs = g, this.updater = n || P;\n    }\n\n    function u() {}\n\n    function c(t, e, n) {\n      this.props = t, this.context = e, this.refs = g, this.updater = n || P;\n    }\n\n    function a(t, e, n) {\n      var r,\n          o = {},\n          i = null,\n          u = null;\n      if (null != e) for (r in void 0 !== e.ref && (u = e.ref), void 0 !== e.key && (i = \"\" + e.key), e) {\n        A.call(e, r) && !$.hasOwnProperty(r) && (o[r] = e[r]);\n      }\n      var c = arguments.length - 2;\n      if (1 === c) o.children = n;else if (c > 1) {\n        for (var a = Array(c), f = 0; c > f; f++) {\n          a[f] = arguments[f + 2];\n        }\n\n        o.children = a;\n      }\n      if (t && t.defaultProps) for (r in c = t.defaultProps) {\n        void 0 === o[r] && (o[r] = c[r]);\n      }\n      return {\n        $$typeof: j,\n        type: t,\n        key: i,\n        ref: u,\n        props: o,\n        _owner: C.current\n      };\n    }\n\n    function f(t) {\n      return \"object\" == typeof t && null !== t && t.$$typeof === j;\n    }\n\n    function l(t) {\n      var e = {\n        \"=\": \"=0\",\n        \":\": \"=2\"\n      };\n      return \"$\" + (\"\" + t).replace(/[=:]/g, function (t) {\n        return e[t];\n      });\n    }\n\n    function s(t, e, n, r) {\n      if (N.length) {\n        var o = N.pop();\n        return o.result = t, o.keyPrefix = e, o.func = n, o.context = r, o.count = 0, o;\n      }\n\n      return {\n        result: t,\n        keyPrefix: e,\n        func: n,\n        context: r,\n        count: 0\n      };\n    }\n\n    function p(t) {\n      t.result = null, t.keyPrefix = null, t.func = null, t.context = null, t.count = 0, 10 > N.length && N.push(t);\n    }\n\n    function y(t, e, n, o) {\n      var i = typeof t;\n      \"undefined\" !== i && \"boolean\" !== i || (t = null);\n      var u = !1;\n      if (null === t) u = !0;else switch (i) {\n        case \"string\":\n        case \"number\":\n          u = !0;\n          break;\n\n        case \"object\":\n          switch (t.$$typeof) {\n            case j:\n            case w:\n            case _:\n            case E:\n              u = !0;\n          }\n\n      }\n      if (u) return n(o, t, \"\" === e ? \".\" + h(t, 0) : e), 1;\n      if (u = 0, e = \"\" === e ? \".\" : e + \":\", Array.isArray(t)) for (var c = 0; t.length > c; c++) {\n        i = t[c];\n        var a = e + h(i, c);\n        u += y(i, a, n, o);\n      } else if (null === t || void 0 === t ? a = null : (a = S && t[S] || t[\"@@iterator\"], a = \"function\" == typeof a ? a : null), \"function\" == typeof a) for (t = a.call(t), c = 0; !(i = t.next()).done;) {\n        i = i.value, a = e + h(i, c++), u += y(i, a, n, o);\n      } else \"object\" === i && (n = \"\" + t, r(\"31\", \"[object Object]\" === n ? \"object with keys {\" + Object.keys(t).join(\", \") + \"}\" : n, \"\"));\n      return u;\n    }\n\n    function h(t, e) {\n      return \"object\" == typeof t && null !== t && null != t.key ? l(t.key) : e.toString(36);\n    }\n\n    function d(t, e) {\n      t.func.call(t.context, e, t.count++);\n    }\n\n    function v(t, e, n) {\n      var r = t.result,\n          o = t.keyPrefix;\n      t = t.func.call(t.context, e, t.count++), Array.isArray(t) ? b(t, r, n, k.thatReturnsArgument) : null != t && (f(t) && (e = o + (!t.key || e && e.key === t.key ? \"\" : (\"\" + t.key).replace(q, \"$&/\") + \"/\") + n, t = {\n        $$typeof: j,\n        type: t.type,\n        key: e,\n        ref: t.ref,\n        props: t.props,\n        _owner: t._owner\n      }), r.push(t));\n    }\n\n    function b(t, e, n, r, o) {\n      var i = \"\";\n      null != n && (i = (\"\" + n).replace(q, \"$&/\") + \"/\"), e = s(e, i, r, o), null == t || y(t, \"\", v, e), p(e);\n    }\n\n    var m = n(7),\n        g = n(8),\n        k = n(1),\n        O = \"function\" == typeof Symbol && Symbol.for,\n        j = O ? Symbol.for(\"react.element\") : 60103,\n        w = O ? Symbol.for(\"react.call\") : 60104,\n        _ = O ? Symbol.for(\"react.return\") : 60105,\n        E = O ? Symbol.for(\"react.portal\") : 60106,\n        x = O ? Symbol.for(\"react.fragment\") : 60107,\n        S = \"function\" == typeof Symbol && Symbol.iterator,\n        P = {\n      isMounted: function isMounted() {\n        return !1;\n      },\n      enqueueForceUpdate: function enqueueForceUpdate() {},\n      enqueueReplaceState: function enqueueReplaceState() {},\n      enqueueSetState: function enqueueSetState() {}\n    };\n\n    o.prototype.isReactComponent = {}, o.prototype.setState = function (t, e) {\n      \"object\" != typeof t && \"function\" != typeof t && null != t && r(\"85\"), this.updater.enqueueSetState(this, t, e, \"setState\");\n    }, o.prototype.forceUpdate = function (t) {\n      this.updater.enqueueForceUpdate(this, t, \"forceUpdate\");\n    }, u.prototype = o.prototype;\n    var T = i.prototype = new u();\n    T.constructor = i, m(T, o.prototype), T.isPureReactComponent = !0;\n    var R = c.prototype = new u();\n    R.constructor = c, m(R, o.prototype), R.unstable_isAsyncReactComponent = !0, R.render = function () {\n      return this.props.children;\n    };\n    var C = {\n      current: null\n    },\n        A = Object.prototype.hasOwnProperty,\n        $ = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    },\n        q = /\\/+/g,\n        N = [],\n        I = {\n      Children: {\n        map: function map(t, e, n) {\n          if (null == t) return t;\n          var r = [];\n          return b(t, r, null, e, n), r;\n        },\n        forEach: function forEach(t, e, n) {\n          if (null == t) return t;\n          e = s(null, null, e, n), null == t || y(t, \"\", d, e), p(e);\n        },\n        count: function count(t) {\n          return null == t ? 0 : y(t, \"\", k.thatReturnsNull, null);\n        },\n        toArray: function toArray(t) {\n          var e = [];\n          return b(t, e, null, k.thatReturnsArgument), e;\n        },\n        only: function only(t) {\n          return f(t) || r(\"143\"), t;\n        }\n      },\n      Component: o,\n      PureComponent: i,\n      unstable_AsyncComponent: c,\n      Fragment: x,\n      createElement: a,\n      cloneElement: function cloneElement(t, e, n) {\n        var r = m({}, t.props),\n            o = t.key,\n            i = t.ref,\n            u = t._owner;\n\n        if (null != e) {\n          if (void 0 !== e.ref && (i = e.ref, u = C.current), void 0 !== e.key && (o = \"\" + e.key), t.type && t.type.defaultProps) var c = t.type.defaultProps;\n\n          for (a in e) {\n            A.call(e, a) && !$.hasOwnProperty(a) && (r[a] = void 0 === e[a] && void 0 !== c ? c[a] : e[a]);\n          }\n        }\n\n        var a = arguments.length - 2;\n        if (1 === a) r.children = n;else if (a > 1) {\n          c = Array(a);\n\n          for (var f = 0; a > f; f++) {\n            c[f] = arguments[f + 2];\n          }\n\n          r.children = c;\n        }\n        return {\n          $$typeof: j,\n          type: t.type,\n          key: o,\n          ref: i,\n          props: r,\n          _owner: u\n        };\n      },\n      createFactory: function createFactory(t) {\n        var e = a.bind(null, t);\n        return e.type = t, e;\n      },\n      isValidElement: f,\n      version: \"16.2.0\",\n      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n        ReactCurrentOwner: C,\n        assign: m\n      }\n    },\n        U = Object.freeze({\n      default: I\n    }),\n        F = U && I || U;\n    t.exports = F.default ? F.default : F;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      if (null === t || void 0 === t) throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n      return Object(t);\n    }\n\n    var o = Object.getOwnPropertySymbols,\n        i = Object.prototype.hasOwnProperty,\n        u = Object.prototype.propertyIsEnumerable;\n    t.exports = function () {\n      try {\n        if (!Object.assign) return !1;\n        var t = new String(\"abc\");\n        if (t[5] = \"de\", \"5\" === Object.getOwnPropertyNames(t)[0]) return !1;\n\n        for (var e = {}, n = 0; 10 > n; n++) {\n          e[\"_\" + String.fromCharCode(n)] = n;\n        }\n\n        if (\"0123456789\" !== Object.getOwnPropertyNames(e).map(function (t) {\n          return e[t];\n        }).join(\"\")) return !1;\n        var r = {};\n        return \"abcdefghijklmnopqrst\".split(\"\").forEach(function (t) {\n          r[t] = t;\n        }), \"abcdefghijklmnopqrst\" === Object.keys(Object.assign({}, r)).join(\"\");\n      } catch (t) {\n        return !1;\n      }\n    }() ? Object.assign : function (t, e) {\n      for (var n, c, a = r(t), f = 1; arguments.length > f; f++) {\n        n = Object(arguments[f]);\n\n        for (var l in n) {\n          i.call(n, l) && (a[l] = n[l]);\n        }\n\n        if (o) {\n          c = o(n);\n\n          for (var s = 0; c.length > s; s++) {\n            u.call(n, c[s]) && (a[c[s]] = n[c[s]]);\n          }\n        }\n      }\n\n      return a;\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = {};\n    t.exports = r;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = n(1),\n        o = n(10),\n        i = n(11);\n\n    t.exports = function () {\n      function t(t, e, n, r, u, c) {\n        c !== i && o(!1, \"Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types\");\n      }\n\n      function e() {\n        return t;\n      }\n\n      t.isRequired = t;\n      var n = {\n        array: t,\n        bool: t,\n        func: t,\n        number: t,\n        object: t,\n        string: t,\n        symbol: t,\n        any: t,\n        arrayOf: e,\n        element: t,\n        instanceOf: e,\n        node: t,\n        objectOf: e,\n        oneOf: e,\n        oneOfType: e,\n        shape: e,\n        exact: e\n      };\n      return n.checkPropTypes = r, n.PropTypes = n, n;\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t, e, n, r, i, u, c, a) {\n      if (o(e), !t) {\n        var f;\n        if (void 0 === e) f = Error(\"Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.\");else {\n          var l = [n, r, i, u, c, a],\n              s = 0;\n          f = Error(e.replace(/%s/g, function () {\n            return l[s++];\n          })), f.name = \"Invariant Violation\";\n        }\n        throw f.framesToPop = 1, f;\n      }\n    }\n\n    var o = function o(t) {};\n\n    t.exports = r;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    t.exports = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\";\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = n(0),\n        o = n.n(r),\n        i = n(2),\n        u = n.n(i),\n        c = n(3),\n        a = Object.assign || function (t) {\n      for (var e = 1; arguments.length > e; e++) {\n        var n = arguments[e];\n\n        for (var r in n) {\n          Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);\n        }\n      }\n\n      return t;\n    },\n        f = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    };\n\n    e.a = function (t) {\n      return function (e) {\n        var n = Object(c.b)(e),\n            r = function r(_r, i) {\n          var u = i.trackEvent,\n              c = {};\n          if (!u) throw Error('Could not find tracker in the context of \"' + n + '\"');\n\n          if (\"function\" == typeof t) {\n            if (!(c = t(u)) || \"object\" !== (void 0 === c ? \"undefined\" : f(c))) throw Error('mapTrackingToProps should return an object, instead it returns \"' + (void 0 === c ? \"undefined\" : f(c)) + '\"');\n          } else c = {\n            trackEvent: u\n          };\n\n          var l = a({}, _r, c);\n          return o.a.createElement(e, l);\n        };\n\n        return r.displayName = n, r.contextTypes = {\n          trackEvent: u.a.func.isRequired\n        }, r;\n      };\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      if (Array.isArray(t)) {\n        for (var e = 0, n = Array(t.length); t.length > e; e++) {\n          n[e] = t[e];\n        }\n\n        return n;\n      }\n\n      return Array.from(t);\n    }\n\n    function o(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    var i = n(3),\n        u = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    },\n        c = function () {\n      function t(t, e) {\n        for (var n = 0; e.length > n; n++) {\n          var r = e[n];\n          r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n        }\n      }\n\n      return function (e, n, r) {\n        return n && t(e.prototype, n), r && t(e, r), e;\n      };\n    }();\n\n    e.a = function () {\n      function t(e) {\n        o(this, t), this.trackingHistory = [], this.listeners = Object(i.a)(e), this.trackEvent = this.trackEvent.bind(this);\n      }\n\n      return c(t, [{\n        key: \"on\",\n        value: function value(t, e) {\n          if (\"function\" != typeof e) throw Error(\"Expected onClick listener to be a function, instead got type \" + (void 0 === e ? \"undefined\" : u(e)));\n          if (\"string\" != typeof t || 1 > t.length) throw Error(\"No event type is specified. (*) to listen on all events\");\n          e.eventType = t, this.listeners = [].concat(r(this.listeners), [e]);\n        }\n      }, {\n        key: \"trackEvent\",\n        value: function value(t) {\n          var e = t || {},\n              n = e.type;\n          if (!n) return null;\n\n          for (var o = 0; this.listeners.length > o; o++) {\n            var i = this.listeners[o];\n\n            if (\"function\" == typeof i && (i.eventType === n || \"*\" === i.eventType || void 0 === i.eventType)) {\n              var u = i.call(null, t, this.trackingHistory);\n              u && (this.trackingHistory = [].concat(r(this.trackingHistory), [u]));\n            }\n          }\n        }\n      }, {\n        key: \"getHistory\",\n        value: function value() {\n          return this.trackingHistory;\n        }\n      }]), t;\n    }();\n  }]);\n});","map":null,"metadata":{},"sourceType":"script"}